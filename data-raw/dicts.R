# TODO: Which dictionaries to include? All? Or should it be limited to those that have been published with (so not gaysex1980)? Should I include subsets (prisoner's dilemma)?

# There are also Rda versions that will be available via data
# I think I will need a method to write datasets generated by the user (or loaded by the user) to the proper location so I can find them to give to BayesACT
# First I am going to worry about the public datasets

source_folder <- "data-raw/dicts"
file_list <- list.files(source_folder)

term_table_ident <-data.frame(term = NA)
term_table_beh <-data.frame(term = NA)
term_table_set <-data.frame(term = NA)
term_table_mod <-data.frame(term = NA)
# term_table_emot <-data.frame(term = NA)

for(file in file_list){
  # should deal with the mean-only datasets and the SD/COV datasets separately
  path <- paste0(source_folder, "/", file)
  component <- stringr::str_extract(file, "(?<=_)[[:alpha:]]*(?=.)")
  key <- stringr::str_extract(file, "^[[:alnum:]]*(?=_)")
  filetype <- stringr::str_extract(file, "\\.[[:alpha:]]*$")
  datatype <- dplyr::case_when(
    grepl("COV", file) ~ "COV",
    grepl("SD", file) ~ "SD",
    TRUE ~ "mean"
  )

  con <- file(path, "r")
  firstline <- readLines(con = con, n = 1)
  close(con)
  if(grepl(',', firstline)){
    # the file is comma-separated
    sep <- ","
  } else {
    # file is space separated
    sep <- " "
  }

  if(grepl('term', firstline)){
    head <- TRUE
  } else {
    head <- FALSE
  }

  data <- read.table(path, header = head, sep = sep, quote = "", fill=FALSE)
  nc <- ncol(data)
  namesplaceholder <- list()
  for(i in 1:nc){
    namesplaceholder <- append(namesplaceholder, paste0("V", i))
  }
  names(data) <- namesplaceholder

  if(datatype == "mean"){
    male <- data %>%
      dplyr::select(-c(V5:V7))
    female <- data %>%
      dplyr::select(-c(V2:V4))
    average <- data %>%
      dplyr::rowwise() %>%
      dplyr::mutate(avE = mean(c(V2, V5)),
             avP = mean(c(V3, V6)),
             avA = mean(c(V4, V7))) %>%
      dplyr::select(-c(V2:V7))

    if(ncol(female) == 5){
      colnames(male) <- c("term", "E", "P", "A", "instcodes")
      colnames(female) <- c("term", "E", "P", "A", "instcodes")
      colnames(average) <- c("term", "instcodes", "E", "P", "A")
      average <- dplyr::select(average, term, E, P, A, instcodes)
    } else {
      colnames(male) <- c("term", "E", "P", "A")
      colnames(female) <- c("term", "E", "P", "A")
      colnames(average) <- c("term", "E", "P", "A")
    }

    # standardize terms
    male <- standardize_terms(male, key, component)
    female <- standardize_terms(female, key, component)
    average <- standardize_terms(average, key, component)

    term_table_input <- cbind(average[,1], rep(1, length(average[,1])))
    colnames(term_table_input) <- c("term", key)

    if(component == 'identities'){
      term_table_ident <- dplyr::full_join(term_table_ident, term_table_input, copy = TRUE)
    } else if (component == 'behaviors'){
      term_table_beh <- dplyr::full_join(term_table_beh, term_table_input, copy = TRUE)
    } else if (component == 'mods'){
      term_table_mod <- dplyr::full_join(term_table_mod, term_table_input, copy = TRUE)
    } else if (component == 'settings'){
      term_table_set <- dplyr::full_join(term_table_set, term_table_input, copy = TRUE)
    }
    # } else if (component == 'emotions'){
    #   term_table_emot <- dplyr::full_join(term_table_emot, term_table_input, copy = TRUE)
    # }

    # are the male and female sets identical? If so the reported values are averages already and need only print one file
    if(isTRUE(all.equal(male$E, female$E))){
      avonly <- TRUE
    } else {
      avonly <- FALSE
    }

    # print average file first
    filename <- paste0(key, "_", component, "_av")
    saveit(average, name = filename)

    # then print male and female files if necessary
    if(avonly == FALSE){
      for(g in c("f", "m")){
        filename <- paste0(key, "_", component, "_", g)

        if(g == 'f'){
          d <- female
        } else {
          d <- male
        }

        saveit(d, name = filename)
      }
    }

    # now deal with covariance datasets which will be different.
    # The one provided (georgia-duke 2015; probably same data as UGA 2015) does not split by gender
    # cov data has 9 additional columns
    # can leave as is with the exception of standardizing term format
  } else if (datatype == "COV") {
    names(data) <- c('term', 'E', 'P', 'A', 'cov1', 'cov2', 'cov3', 'cov4', 'cov5', 'cov6', 'cov7', 'cov8', 'cov9')
    data_clean <- standardize_terms(data, key, component)
    filename <- paste0(key, "_", component, "_av_COV")
    saveit(data_clean, name = filename)

    term_table_input <- cbind(data_clean[,1], rep(1, length(data_clean[,1])))
    colnames(term_table_input) <- c("term", key)

    if(component == 'identities'){
      term_table_ident <- dplyr::full_join(term_table_ident, term_table_input, copy = TRUE)
    } else if (component == 'behaviors'){
      term_table_beh <- dplyr::full_join(term_table_beh, term_table_input, copy = TRUE)
    } else if (component == 'mods'){
      term_table_mod <- dplyr::full_join(term_table_mod, term_table_input, copy = TRUE)
    } else if (component == 'settings'){
      term_table_set <- dplyr::full_join(term_table_set, term_table_input, copy = TRUE)
    }
    # } else if (component == 'emotions'){
    #   term_table_emot <- dplyr::full_join(term_table_emot, term_table_input, copy = TRUE)
    # }

  } else if (datatype == "SD") {
    # standard deviation has three additional columns; does not split by gender
    names(data) <- c('term', 'E', 'P', 'A', 'sd1', 'sd2', 'sd3')
    data_clean <- standardize_terms(data, key, component)
    filename <- paste0(key, "_", component, "_av_SD")
    saveit(data_clean, name = filename)

    term_table_input <- cbind(data_clean[,1], rep(1, length(data_clean[,1])))
    colnames(term_table_input) <- c("term", key)

    if(component == 'identities'){
      term_table_ident <- dplyr::full_join(term_table_ident, term_table_input, copy = TRUE)
    } else if (component == 'behaviors'){
      term_table_beh <- dplyr::full_join(term_table_beh, term_table_input, copy = TRUE)
    } else if (component == 'mods'){
      term_table_mod <- dplyr::full_join(term_table_mod, term_table_input, copy = TRUE)
    } else if (component == 'settings'){
      term_table_set <- dplyr::full_join(term_table_set, term_table_input, copy = TRUE)
    }
    # } else if (component == 'emotions'){
    #   term_table_emot <- dplyr::full_join(term_table_emot, term_table_input, copy = TRUE)
    # }
  }
}

term_table_cleanup <- function(term_table){
  clean_table <- dplyr::filter(term_table, !is.na(term))
  clean_table[is.na(clean_table)] <- 0
  clean_table <- dplyr::mutate(clean_table, dplyr::across(-term, as.numeric))
  clean_table <- dplyr::arrange(clean_table, term)
  clean_table <- unique(clean_table)
  return(clean_table)
}

term_table_ident <- term_table_cleanup(term_table_ident)
term_table_beh <- term_table_cleanup(term_table_beh)
term_table_set <- term_table_cleanup(term_table_set)
term_table_mod <- term_table_cleanup(term_table_mod)
# term_table_emot <- term_table_cleanup(term_table_emot)

usethis::use_data(term_table_ident, overwrite = TRUE)
usethis::use_data(term_table_beh, overwrite = TRUE)
usethis::use_data(term_table_set, overwrite = TRUE)
usethis::use_data(term_table_mod, overwrite = TRUE)
# usethis::use_data(term_table_emot, overwrite = TRUE)


